[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Nathan Jones"
  },
  {
    "objectID": "about.html#background",
    "href": "about.html#background",
    "title": "About Me",
    "section": "Background",
    "text": "Background\nMy name is Nathan Jones, and I am a student at Brigham Young University studying Machine Learning. I have a strong interest in using Statistics and Machine Learning techniques to explore, visualize, and find answers in data. I am also passionate about practical use cases for AI systems that can help automate workflows, both in professional and creative settings."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\nBrigham Young University\n\nBachelor of Science in Machine Learning\n\nExpected Graduation: April 2027\n\n\nRelevant Coursework:\n\nAdvanced Machine Learning\nDeep Learning\nData Science Processes\nMathematics of Data Science"
  },
  {
    "objectID": "about.html#skills-interests",
    "href": "about.html#skills-interests",
    "title": "About Me",
    "section": "Skills & Interests",
    "text": "Skills & Interests\n\nTechnical Skills\n\nProgramming: Python, C++, Java, JavaScript, C\n\nData Analysis & ML: Pandas, NumPy, scikit-learn, PyTorch\n\nVisualization: Matplotlib\n\nTools: Git, GitHub, Jupyter Notebooks, SQL, Tableau\n\n\n\nAreas of Interest\n\nHuman–AI collaboration in creative tools and workflows\n\nReinforcement learning for games and simulations\n\nComputer vision and perception-based models\n\nIntelligent systems for prediction, decision-making, and automation"
  },
  {
    "objectID": "about.html#goals",
    "href": "about.html#goals",
    "title": "About Me",
    "section": "Goals",
    "text": "Goals\nCurrently, I am working to deepen my understanding of modern machine learning techniques, particularly reinforcement learning and deep learning. My goal is to become more proficient in these areas, and to come up with workflow outlines that can be generally applied when approaching a problem for the first time.\nLong-term, I hope to pursue graduate study in machine learning or a related field. Upon graduating, I hope to work for a tech company to help solve large scale real world problems using techniques of data science and machine learning that I’ve learned in my schooling."
  },
  {
    "objectID": "about.html#contact",
    "href": "about.html#contact",
    "title": "About Me",
    "section": "Contact",
    "text": "Contact\n\nEmail: nathanyjones@gmail.com\n\nGitHub: github.com/nathanyjones\nLinkedIn: linkedin.com/in/nathan-jones-757529162\n\n\nThis portfolio showcases my learning progress and projects completed during my data science studies."
  },
  {
    "objectID": "regex-tutorial.html",
    "href": "regex-tutorial.html",
    "title": "Regex Tutorial",
    "section": "",
    "text": "This tutorial serves as a guide for using regular expressions in python. We will first briefly look at what regex is and why it is useful, then how to create and format regular expressions, and finally how to use the regex library in python.\n\n\n\n\nSimply put, regular expressions are strings constructed to define patterns used to match sequences of text.\n\n\n\nRegex has a variety of applications across many fields. In the field of data science, regex is commonly used for data cleaning.\nFor example, suppose you have a large dataset that stores a variety of dates as strings. Now, further suppose that these dates do not have a uniform format. For instance, “03/04/26”, “3/4/26”, and “03/4/2026” all represent the same date, but the slight differences in format may make them harder to gather and parse. Regex allows you to construct a pattern that matches these variations, allowing them to be identified and processed equally as dates.\nAnother place where regex is useful is extracting structured data from unstructured text. For instance, given a group of forms, regex might be used to validate proper formatting for the inputs, and then extract certain identifiable features, including ID numbers, phone numbers, names, and others.\n\n\n\n\nA regular expression can be built from several key elements: Literal characters, character classes, quantifiers, grouping symbols, alternation, and anchors. We will go over each of these elements, but for a more in depth description, check out the python re library documentation\n\n\n\nLiteral characters are simply characters that match themselves.\nExample:\nPattern:            \"Hello world\"\n\nMatches:            \"Hello world\"\n                    \"This program says, Hello world!\"\n\nDoes not Match:     \"Goodbye\"       # Does not contain \"Hello world\"\n                    \"hello World\"   # Case Sensitive\n                    \"HelloWorld\"    # Whitespace Sensitive\n                    ...\n\n\n\n\nA character class is a set of characters that will match any one of the characters in the set. Character classes are generally denoted with square brackets as shown below.\nExample:\nPattern:            \"[abc][123]\"\n\nMatches:            \"a2\"\n                    \"b1\"\n                    \"c3\"\n                    ...\n\nDoes not Match:     \"d\"     # Not in the character class\n                    \"!\"     # Not in the character class\n                    ...\nYou can also specify ranges in the form: “[a-z]”, which will match any character between lowercase ‘a’ and lowercase ‘z’.\nExample:\nPattern:            \"[a-zA-Z0-9]\"\n\nMatches:            \"a\"\n                    \"Q\"\n                    \"9\"\n                    ...\n\nDoes not Match:     \"!\"     # Not in class ranges\n                    ...\nThere are certain predefined character classes in regex that assigned to shorthand metacharacters for ease of use. These are accessed using a backslash and an identifying character, a few of which can be found in the following table:\n\n\n\n\n\n\n\n\nShorthand\nEquivalent To\nMatches\n\n\n\n\n\\d\n[0-9]\nAny digit (0–9)\n\n\n\\D\n[^0-9]\nAny non-digit\n\n\n\\w\n[a-zA-Z0-9_]\nWord characters (letters, digits, underscore)\n\n\n\\W\n[^a-zA-Z0-9_]\nNon-word characters\n\n\n\\s\n[ \\t\\n\\r\\f\\v]\nAny whitespace character\n\n\n\\S\n[^ \\t\\n\\r\\f\\v]\nAny non-whitespace character\n\n\n\n*Note that the ^ symbol at the start of a character class indicates the negation of the proceeding characters. More on this later.\nExample:\nPattern:        \"\\w\\w\\s\\d\\d\"\n\nMatches:        \"Az 63\"\n                \"27 27\"\n                ...\n\nDoes not Match: \"ABC23\"     # No matching whitespace character\n                \"ab cd\"     # 'cd' doesn't match \\d (digit) identifier\n                ...\n\n\n\n\nQuantifiers provide a way to specify repeated characters or character classes, and is the alternative to rewriting characters or character classes.\nTo use a quantifier, you generally type the respective metacharacter immediately after the character or character class you wish to repeat. The following table contains a list of the most common quantifiers and the number of repeats they specify:\n\n\n\n\n\n\n\n\n\n\nQuantifier\nMeaning\nExample Pattern\nMatches\nDoes Not Match\n\n\n\n\n*\n0 or more of the previous element\nab*\na, ab, abb\nb\n\n\n+\n1 or more of the previous element\nab+\nab, abb\na\n\n\n?\n0 or 1 of the previous element (optional)\ncolou?r\ncolor, colour\ncolouur\n\n\n{n}\nExactly n occurrences\n\\d{3}\n123\n12, 1234\n\n\n{n,}\nn or more occurrences\n\\d{2,}\n12, 12345\n1\n\n\n{n,m}\nBetween n and m occurrences\n\\d{2,4}\n12, 123, 1234\n1, 12345\n\n\n\nExample:\nPattern:        \"a?\\d+\"\n\nMatches:        \"a123\"\n                \"1\"\n                \"12\"\n                ...\n\nDoes not Match: \"a\"         # \\d+ requires one or more digits\n                ...\nNote that if we want a regular expression to match the character that a quantifier uses, like ‘+’, you must specify that you want to use the character and not the quantifier by using the backslash character right before.\n\n\n\n\nSuppose we wanted to match a string consisting of a repeated ‘abc’ subsequence. Intuitively, we can use parentheses to group pieces of a regular expression together to more fully utilize quantifiers and other operators.\nExamples:\nPattern:        \"(abc)+\"\n\nMatches:        \"abc\"\n                \"abcabcabc\"\n                ...\n\nDoes not Match: \"a\"     # Note (abc) is a string, not the character class [abc].\n                \"\"      # The + quantifier indicates 'abc' must appear at least once.\n                ...\nPattern:        \"([efg]\\d+)+\"\n\nMatches:        \"e123\"\n                \"f1g23e456\"\n                ...\n\nDoes not Match: \"efg123\"     # Each [efg] character must be followed by one or more digits.\n                ...\n\n\n\n\nUsing a character class with two elements allows us to match either character once. Often, we want to accomplish a similar task with whole words, rather than single characters. This can be done with the pipe ‘|’ symbol. Using the grouping symbols with alternation allows you to specify options for words and characters to match.\nExamples:\nPattern:            \"the (cat)|(dog)|(frog)\"\n\nString:             \"the cat and the dog sleep with a frog\"\n\nMatches:            \"the cat\"\n                    \"the dog\"\n\nDoes not Match:     \"a frog\"    # Missing 'the', otherwise would match\n\n\n\n\nAnchors are symbols that match positions, and are often used to ensure that your regular expression matches only whole words.\nFor example, suppose you want to find all instances of the word ‘the’ in a string of text.\nPattern:        \"the\"\n\nString:         \"the mother and the father had a child\"\n\nMatches:        \"the\"   # Start of string\n                \"the\"   # Inside \"mo[the]r\"\n                \"the\"   # Standalone word\n                \"the\"   # Inside \"fa[the]r\"\nClearly, this is not the intended behavior, and anchors present a solution. The most common anchors can be found in the following table:\n\n\n\n\n\n\n\n\n\n\nAnchor\nMeaning\nMatches Position\nExample Pattern\nWhat It Matches\n\n\n\n\n^\nStart of string\nBefore the first character\n^Hello\n\"Hello world\" but not \"Say Hello\"\n\n\n$\nEnd of string\nAfter the last character\nworld$\n\"Hello world\" but not \"worldwide\"\n\n\n\\b\nWord boundary\nBetween word and non-word characters\n\\bthe\\b\n\"the cat\" but not \"mother\"\n\n\n\\B\nNot a word boundary\nInside a word\n\\Bthe\\B\n\"mother\" but not \"the cat\"\n\n\n\nUsing the word boundary anchor, we can construct an expression with the intended behavior for the example above:\nPattern:        \"\\bthe\\b\"\n\nString:         \"the mother and the father had a child\"\n\nMatches:        \"the\"   # Start of string\n                \"the\"   # Standalone word\n\n\n\n\nAll of the pieces we’ve covered can be used in harmony to create regular expressions to meet our needs. Going back to the date example from the beginning, we can use these tools to create a regular expression that matches dates with slight variations in format:\nMatches:        \"3/4/26\"\n                \"03/04/26\"\n                \"03/4/2026\"\n\nPattern:        \"\\b\\d{1,2}/\\d{1,2}/\\d{2,4}\\b\"\nNote that this is a somewhat naive approach for identifying dates, and this pattern will also match nonexistent dates, such as “74/74/1974”. However, there are other techniques for date validation, and this pattern will catch all dates of this format. Furthermore, we could fine-tune this pattern to match other date formats to catch more edge cases, which could be easily accomplished with more examples of date formats to match.\n\n\n\n\n\n\nNow that we know how to create regular expressions, we can learn how to make use of them in python. Python has a specific library for regex called re, which can be imported as follows:\nimport re\nThe re library has several functions, both for matching strings and for modifying strings. You can find the full documentation here.\nA few of the useful python re matching functions are listed in the following table:\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nReturns\nExample\n\n\n\n\nre.search(pattern, string)\nSearches the string for the first occurrence of the pattern anywhere\nMatch object or None\nre.search(r\"\\d+\", \"abc123\")\n\n\nre.match(pattern, string)\nChecks for a match only at the beginning of the string\nMatch object or None\nre.match(r\"\\d+\", \"123abc\")\n\n\nre.fullmatch(pattern, string)\nEnsures the entire string matches the pattern\nMatch object or None\nre.fullmatch(r\"\\d+\", \"123\")\n\n\nre.findall(pattern, string)\nReturns all non-overlapping matches as a list\nList of matches\nre.findall(r\"\\d+\", \"a1b22c333\")\n\n\nre.finditer(pattern, string)\nReturns an iterator of match objects\nIterator of Match objects\nre.finditer(r\"\\d+\", \"a1b22\")\n\n\n\nNotice the r character used before the pattern string. In python, the r specifies a raw string, preventing python from interpreting backslashes as escape characters. Additionally, functions like re.search() return a match object, so we use .group() to extract the actual matched text.\nExample:\ntext = \"John: 123-456-7890, Jane: 555-555-5555\"\npattern = r\"\\d{3}-\\d{3}-\\d{4}\"\n\n# re.search() — finds first match anywhere\nprint(re.search(pattern, text).group())\n# Output: 123-456-7890\n\n# re.match() — only checks beginning of string\nprint(re.match(pattern, text))\n# Output: None\n\n# re.findall() — returns all matches\nprint(re.findall(pattern, text))\n# Output: ['123-456-7890', '555-555-5555']\nIn some cases, we want to modify text rather than just search or extract it. Python’s re library also provides functions for replacing, splitting, or counting matches. These allow you to efficiently clean, transform, or restructure strings.\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nReturns\nExample\n\n\n\n\nre.sub(pattern, replacement, string)\nReplaces matches with a replacement string\nModified string\nre.sub(r\"\\d+\", \"#\", \"a1b22\")\n\n\nre.subn(pattern, replacement, string)\nSame as sub, but also returns number of replacements\n(new_string, count)\nre.subn(r\"\\d+\", \"#\", \"a1b22\")\n\n\nre.split(pattern, string)\nSplits a string at each match of the pattern\nList of substrings\nre.split(r\"\\s+\", \"a b   c\")\n\n\n\nDepending on the method, these functions will return either a modified string, a tuple, or a list.\nExample:\ntext = \"John: 123-456-7890, Jane: 555-555-5555\"\npattern = r\"\\d{3}-\\d{3}-\\d{4}\"\n\n# Replace all phone numbers with a placeholder\nprint(re.sub(pattern, \"XXX-XXX-XXXX\", text))\n# Output: John: XXX-XXX-XXXX, Jane: XXX-XXX-XXXX\n\n# Replace and get number of replacements\nprint(re.subn(pattern, \"XXX-XXX-XXXX\", text))\n# Output: ('John: XXX-XXX-XXXX, Jane: XXX-XXX-XXXX', 2)\n\n# Split the string at each phone number\nprint(re.split(pattern, text))\n# Output: ['John: ', ', Jane: ', '']\nThese functions allow you to easily transform text in customizable ways, which is useful for reformatting data, replacing sensitive information, cleaning text, and much more.\n\n\n\nFinally, pandas makes it easy to use regular expressions to clean, extract, and transform data in a DataFrames. To use regex methods on DataFrames, you typically call the method on DataFrame.str.\n\n\n\n\n\n\n\n\n\nFunction / Method\nDescription\nReturns\nExample\n\n\n\n\ndf['col'].str.contains(pattern)\nReturns a boolean Series indicating whether each row matches the pattern\nBoolean Series\ndf['text'].str.contains(r\"\\d+\")\n\n\ndf['col'].str.match(pattern)\nChecks if the entire string in each row matches the pattern\nBoolean Series\ndf['text'].str.match(r\"\\d{3}-\\d{3}-\\d{4}\")\n\n\ndf['col'].str.replace(pattern, repl, regex=True)\nReplaces matches with a replacement string (regex must be enabled)\nSeries with replaced text\ndf['text'].str.replace(r\"\\d+\", \"#\", regex=True)\n\n\ndf['col'].str.extract(pattern)\nExtracts capture groups from the pattern into new columns\nDataFrame\ndf['text'].str.extract(r\"(\\d{3})-(\\d{3})-(\\d{4})\")\n\n\ndf['col'].str.findall(pattern)\nReturns all matches in each row as a list\nSeries of lists\ndf['text'].str.findall(r\"\\d{3}-\\d{3}-\\d{4}\")\n\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"name\": [\"John\", \"Jane\"],\n    \"contact\": [\"123-456-7890\", \"555-555-5555\"]\n})\n\n# Check which rows contain a phone number\nprint(df['contact'].str.contains(r\"\\d{3}-\\d{3}-\\d{4}\"))\n# Output:\n# 0    True\n# 1    True\n# Name: contact, dtype: bool\n\n# Extract area codes (first three digits) into a new column\ndf['area_code'] = df['contact'].str.extract(r\"(\\d{3})\")\nprint(df)\n# Output:\n#    name                     contact area_code\n# 0  John  123-456-7890       123\n# 1  Jane  555-555-5555       555\n\n# Replace phone numbers with a placeholder\ndf['contact_masked'] = df['contact'].str.replace(r\"\\d{3}-\\d{3}-\\d{4}\", \"XXX-XXX-XXXX\", regex=True)\nprint(df)\n# Output:\n#    name                     contact area_code   contact_masked\n# 0  John  123-456-7890       123                 XXX-XXX-XXXX\n# 1  Jane  555-555-5555       555                 XXX-XXX-XXXX\nNote that the regex parameter in the replace method should be set to True whenever you want to treat the pattern as regex. Furthermore, the pattern for the extract method should be enclosed in parentheses.\nThese built-in pandas string methods allow you to combine regex with pandas to quickly clean, extract, and transform text across DataFrame columns.\n\n\n\n\nRegular expressions are powerful for finding, extracting, and changing pieces of text. Python’s re library makes it easy to identify and replace patterns in string, and pandas allows you to do this across columns of data efficiently.\nWhether you’re cleaning messy datasets, extracting phone numbers, IDs, or other info, or just masking sensitive data, regex makes it way easier and more flexible than trying to do everything with plain python.\nTry messing around with your own patterns on some text or data you have, see what you can extract, or try replacing things in different ways. Regex is best learned through experimentation, so I urge you to practice these concepts yourself. And feel free to reference the tables in this tutorial as a quick guide in your exploration.\nYou can start experimenting with constructing regex expressions right now with regex101.com, or learn more about regex here."
  },
  {
    "objectID": "regex-tutorial.html#introduction-to-regex",
    "href": "regex-tutorial.html#introduction-to-regex",
    "title": "Regex Tutorial",
    "section": "",
    "text": "Simply put, regular expressions are strings constructed to define patterns used to match sequences of text.\n\n\n\nRegex has a variety of applications across many fields. In the field of data science, regex is commonly used for data cleaning.\nFor example, suppose you have a large dataset that stores a variety of dates as strings. Now, further suppose that these dates do not have a uniform format. For instance, “03/04/26”, “3/4/26”, and “03/4/2026” all represent the same date, but the slight differences in format may make them harder to gather and parse. Regex allows you to construct a pattern that matches these variations, allowing them to be identified and processed equally as dates.\nAnother place where regex is useful is extracting structured data from unstructured text. For instance, given a group of forms, regex might be used to validate proper formatting for the inputs, and then extract certain identifiable features, including ID numbers, phone numbers, names, and others."
  },
  {
    "objectID": "regex-tutorial.html#building-regular-expressions",
    "href": "regex-tutorial.html#building-regular-expressions",
    "title": "Regex Tutorial",
    "section": "",
    "text": "A regular expression can be built from several key elements: Literal characters, character classes, quantifiers, grouping symbols, alternation, and anchors. We will go over each of these elements, but for a more in depth description, check out the python re library documentation\n\n\n\nLiteral characters are simply characters that match themselves.\nExample:\nPattern:            \"Hello world\"\n\nMatches:            \"Hello world\"\n                    \"This program says, Hello world!\"\n\nDoes not Match:     \"Goodbye\"       # Does not contain \"Hello world\"\n                    \"hello World\"   # Case Sensitive\n                    \"HelloWorld\"    # Whitespace Sensitive\n                    ...\n\n\n\n\nA character class is a set of characters that will match any one of the characters in the set. Character classes are generally denoted with square brackets as shown below.\nExample:\nPattern:            \"[abc][123]\"\n\nMatches:            \"a2\"\n                    \"b1\"\n                    \"c3\"\n                    ...\n\nDoes not Match:     \"d\"     # Not in the character class\n                    \"!\"     # Not in the character class\n                    ...\nYou can also specify ranges in the form: “[a-z]”, which will match any character between lowercase ‘a’ and lowercase ‘z’.\nExample:\nPattern:            \"[a-zA-Z0-9]\"\n\nMatches:            \"a\"\n                    \"Q\"\n                    \"9\"\n                    ...\n\nDoes not Match:     \"!\"     # Not in class ranges\n                    ...\nThere are certain predefined character classes in regex that assigned to shorthand metacharacters for ease of use. These are accessed using a backslash and an identifying character, a few of which can be found in the following table:\n\n\n\n\n\n\n\n\nShorthand\nEquivalent To\nMatches\n\n\n\n\n\\d\n[0-9]\nAny digit (0–9)\n\n\n\\D\n[^0-9]\nAny non-digit\n\n\n\\w\n[a-zA-Z0-9_]\nWord characters (letters, digits, underscore)\n\n\n\\W\n[^a-zA-Z0-9_]\nNon-word characters\n\n\n\\s\n[ \\t\\n\\r\\f\\v]\nAny whitespace character\n\n\n\\S\n[^ \\t\\n\\r\\f\\v]\nAny non-whitespace character\n\n\n\n*Note that the ^ symbol at the start of a character class indicates the negation of the proceeding characters. More on this later.\nExample:\nPattern:        \"\\w\\w\\s\\d\\d\"\n\nMatches:        \"Az 63\"\n                \"27 27\"\n                ...\n\nDoes not Match: \"ABC23\"     # No matching whitespace character\n                \"ab cd\"     # 'cd' doesn't match \\d (digit) identifier\n                ...\n\n\n\n\nQuantifiers provide a way to specify repeated characters or character classes, and is the alternative to rewriting characters or character classes.\nTo use a quantifier, you generally type the respective metacharacter immediately after the character or character class you wish to repeat. The following table contains a list of the most common quantifiers and the number of repeats they specify:\n\n\n\n\n\n\n\n\n\n\nQuantifier\nMeaning\nExample Pattern\nMatches\nDoes Not Match\n\n\n\n\n*\n0 or more of the previous element\nab*\na, ab, abb\nb\n\n\n+\n1 or more of the previous element\nab+\nab, abb\na\n\n\n?\n0 or 1 of the previous element (optional)\ncolou?r\ncolor, colour\ncolouur\n\n\n{n}\nExactly n occurrences\n\\d{3}\n123\n12, 1234\n\n\n{n,}\nn or more occurrences\n\\d{2,}\n12, 12345\n1\n\n\n{n,m}\nBetween n and m occurrences\n\\d{2,4}\n12, 123, 1234\n1, 12345\n\n\n\nExample:\nPattern:        \"a?\\d+\"\n\nMatches:        \"a123\"\n                \"1\"\n                \"12\"\n                ...\n\nDoes not Match: \"a\"         # \\d+ requires one or more digits\n                ...\nNote that if we want a regular expression to match the character that a quantifier uses, like ‘+’, you must specify that you want to use the character and not the quantifier by using the backslash character right before.\n\n\n\n\nSuppose we wanted to match a string consisting of a repeated ‘abc’ subsequence. Intuitively, we can use parentheses to group pieces of a regular expression together to more fully utilize quantifiers and other operators.\nExamples:\nPattern:        \"(abc)+\"\n\nMatches:        \"abc\"\n                \"abcabcabc\"\n                ...\n\nDoes not Match: \"a\"     # Note (abc) is a string, not the character class [abc].\n                \"\"      # The + quantifier indicates 'abc' must appear at least once.\n                ...\nPattern:        \"([efg]\\d+)+\"\n\nMatches:        \"e123\"\n                \"f1g23e456\"\n                ...\n\nDoes not Match: \"efg123\"     # Each [efg] character must be followed by one or more digits.\n                ...\n\n\n\n\nUsing a character class with two elements allows us to match either character once. Often, we want to accomplish a similar task with whole words, rather than single characters. This can be done with the pipe ‘|’ symbol. Using the grouping symbols with alternation allows you to specify options for words and characters to match.\nExamples:\nPattern:            \"the (cat)|(dog)|(frog)\"\n\nString:             \"the cat and the dog sleep with a frog\"\n\nMatches:            \"the cat\"\n                    \"the dog\"\n\nDoes not Match:     \"a frog\"    # Missing 'the', otherwise would match\n\n\n\n\nAnchors are symbols that match positions, and are often used to ensure that your regular expression matches only whole words.\nFor example, suppose you want to find all instances of the word ‘the’ in a string of text.\nPattern:        \"the\"\n\nString:         \"the mother and the father had a child\"\n\nMatches:        \"the\"   # Start of string\n                \"the\"   # Inside \"mo[the]r\"\n                \"the\"   # Standalone word\n                \"the\"   # Inside \"fa[the]r\"\nClearly, this is not the intended behavior, and anchors present a solution. The most common anchors can be found in the following table:\n\n\n\n\n\n\n\n\n\n\nAnchor\nMeaning\nMatches Position\nExample Pattern\nWhat It Matches\n\n\n\n\n^\nStart of string\nBefore the first character\n^Hello\n\"Hello world\" but not \"Say Hello\"\n\n\n$\nEnd of string\nAfter the last character\nworld$\n\"Hello world\" but not \"worldwide\"\n\n\n\\b\nWord boundary\nBetween word and non-word characters\n\\bthe\\b\n\"the cat\" but not \"mother\"\n\n\n\\B\nNot a word boundary\nInside a word\n\\Bthe\\B\n\"mother\" but not \"the cat\"\n\n\n\nUsing the word boundary anchor, we can construct an expression with the intended behavior for the example above:\nPattern:        \"\\bthe\\b\"\n\nString:         \"the mother and the father had a child\"\n\nMatches:        \"the\"   # Start of string\n                \"the\"   # Standalone word\n\n\n\n\nAll of the pieces we’ve covered can be used in harmony to create regular expressions to meet our needs. Going back to the date example from the beginning, we can use these tools to create a regular expression that matches dates with slight variations in format:\nMatches:        \"3/4/26\"\n                \"03/04/26\"\n                \"03/4/2026\"\n\nPattern:        \"\\b\\d{1,2}/\\d{1,2}/\\d{2,4}\\b\"\nNote that this is a somewhat naive approach for identifying dates, and this pattern will also match nonexistent dates, such as “74/74/1974”. However, there are other techniques for date validation, and this pattern will catch all dates of this format. Furthermore, we could fine-tune this pattern to match other date formats to catch more edge cases, which could be easily accomplished with more examples of date formats to match."
  },
  {
    "objectID": "regex-tutorial.html#using-regex-in-python",
    "href": "regex-tutorial.html#using-regex-in-python",
    "title": "Regex Tutorial",
    "section": "",
    "text": "Now that we know how to create regular expressions, we can learn how to make use of them in python. Python has a specific library for regex called re, which can be imported as follows:\nimport re\nThe re library has several functions, both for matching strings and for modifying strings. You can find the full documentation here.\nA few of the useful python re matching functions are listed in the following table:\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nReturns\nExample\n\n\n\n\nre.search(pattern, string)\nSearches the string for the first occurrence of the pattern anywhere\nMatch object or None\nre.search(r\"\\d+\", \"abc123\")\n\n\nre.match(pattern, string)\nChecks for a match only at the beginning of the string\nMatch object or None\nre.match(r\"\\d+\", \"123abc\")\n\n\nre.fullmatch(pattern, string)\nEnsures the entire string matches the pattern\nMatch object or None\nre.fullmatch(r\"\\d+\", \"123\")\n\n\nre.findall(pattern, string)\nReturns all non-overlapping matches as a list\nList of matches\nre.findall(r\"\\d+\", \"a1b22c333\")\n\n\nre.finditer(pattern, string)\nReturns an iterator of match objects\nIterator of Match objects\nre.finditer(r\"\\d+\", \"a1b22\")\n\n\n\nNotice the r character used before the pattern string. In python, the r specifies a raw string, preventing python from interpreting backslashes as escape characters. Additionally, functions like re.search() return a match object, so we use .group() to extract the actual matched text.\nExample:\ntext = \"John: 123-456-7890, Jane: 555-555-5555\"\npattern = r\"\\d{3}-\\d{3}-\\d{4}\"\n\n# re.search() — finds first match anywhere\nprint(re.search(pattern, text).group())\n# Output: 123-456-7890\n\n# re.match() — only checks beginning of string\nprint(re.match(pattern, text))\n# Output: None\n\n# re.findall() — returns all matches\nprint(re.findall(pattern, text))\n# Output: ['123-456-7890', '555-555-5555']\nIn some cases, we want to modify text rather than just search or extract it. Python’s re library also provides functions for replacing, splitting, or counting matches. These allow you to efficiently clean, transform, or restructure strings.\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nReturns\nExample\n\n\n\n\nre.sub(pattern, replacement, string)\nReplaces matches with a replacement string\nModified string\nre.sub(r\"\\d+\", \"#\", \"a1b22\")\n\n\nre.subn(pattern, replacement, string)\nSame as sub, but also returns number of replacements\n(new_string, count)\nre.subn(r\"\\d+\", \"#\", \"a1b22\")\n\n\nre.split(pattern, string)\nSplits a string at each match of the pattern\nList of substrings\nre.split(r\"\\s+\", \"a b   c\")\n\n\n\nDepending on the method, these functions will return either a modified string, a tuple, or a list.\nExample:\ntext = \"John: 123-456-7890, Jane: 555-555-5555\"\npattern = r\"\\d{3}-\\d{3}-\\d{4}\"\n\n# Replace all phone numbers with a placeholder\nprint(re.sub(pattern, \"XXX-XXX-XXXX\", text))\n# Output: John: XXX-XXX-XXXX, Jane: XXX-XXX-XXXX\n\n# Replace and get number of replacements\nprint(re.subn(pattern, \"XXX-XXX-XXXX\", text))\n# Output: ('John: XXX-XXX-XXXX, Jane: XXX-XXX-XXXX', 2)\n\n# Split the string at each phone number\nprint(re.split(pattern, text))\n# Output: ['John: ', ', Jane: ', '']\nThese functions allow you to easily transform text in customizable ways, which is useful for reformatting data, replacing sensitive information, cleaning text, and much more.\n\n\n\nFinally, pandas makes it easy to use regular expressions to clean, extract, and transform data in a DataFrames. To use regex methods on DataFrames, you typically call the method on DataFrame.str.\n\n\n\n\n\n\n\n\n\nFunction / Method\nDescription\nReturns\nExample\n\n\n\n\ndf['col'].str.contains(pattern)\nReturns a boolean Series indicating whether each row matches the pattern\nBoolean Series\ndf['text'].str.contains(r\"\\d+\")\n\n\ndf['col'].str.match(pattern)\nChecks if the entire string in each row matches the pattern\nBoolean Series\ndf['text'].str.match(r\"\\d{3}-\\d{3}-\\d{4}\")\n\n\ndf['col'].str.replace(pattern, repl, regex=True)\nReplaces matches with a replacement string (regex must be enabled)\nSeries with replaced text\ndf['text'].str.replace(r\"\\d+\", \"#\", regex=True)\n\n\ndf['col'].str.extract(pattern)\nExtracts capture groups from the pattern into new columns\nDataFrame\ndf['text'].str.extract(r\"(\\d{3})-(\\d{3})-(\\d{4})\")\n\n\ndf['col'].str.findall(pattern)\nReturns all matches in each row as a list\nSeries of lists\ndf['text'].str.findall(r\"\\d{3}-\\d{3}-\\d{4}\")\n\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"name\": [\"John\", \"Jane\"],\n    \"contact\": [\"123-456-7890\", \"555-555-5555\"]\n})\n\n# Check which rows contain a phone number\nprint(df['contact'].str.contains(r\"\\d{3}-\\d{3}-\\d{4}\"))\n# Output:\n# 0    True\n# 1    True\n# Name: contact, dtype: bool\n\n# Extract area codes (first three digits) into a new column\ndf['area_code'] = df['contact'].str.extract(r\"(\\d{3})\")\nprint(df)\n# Output:\n#    name                     contact area_code\n# 0  John  123-456-7890       123\n# 1  Jane  555-555-5555       555\n\n# Replace phone numbers with a placeholder\ndf['contact_masked'] = df['contact'].str.replace(r\"\\d{3}-\\d{3}-\\d{4}\", \"XXX-XXX-XXXX\", regex=True)\nprint(df)\n# Output:\n#    name                     contact area_code   contact_masked\n# 0  John  123-456-7890       123                 XXX-XXX-XXXX\n# 1  Jane  555-555-5555       555                 XXX-XXX-XXXX\nNote that the regex parameter in the replace method should be set to True whenever you want to treat the pattern as regex. Furthermore, the pattern for the extract method should be enclosed in parentheses.\nThese built-in pandas string methods allow you to combine regex with pandas to quickly clean, extract, and transform text across DataFrame columns."
  },
  {
    "objectID": "regex-tutorial.html#conclusion",
    "href": "regex-tutorial.html#conclusion",
    "title": "Regex Tutorial",
    "section": "",
    "text": "Regular expressions are powerful for finding, extracting, and changing pieces of text. Python’s re library makes it easy to identify and replace patterns in string, and pandas allows you to do this across columns of data efficiently.\nWhether you’re cleaning messy datasets, extracting phone numbers, IDs, or other info, or just masking sensitive data, regex makes it way easier and more flexible than trying to do everything with plain python.\nTry messing around with your own patterns on some text or data you have, see what you can extract, or try replacing things in different ways. Regex is best learned through experimentation, so I urge you to practice these concepts yourself. And feel free to reference the tables in this tutorial as a quick guide in your exploration.\nYou can start experimenting with constructing regex expressions right now with regex101.com, or learn more about regex here."
  },
  {
    "objectID": "projects/final-project.html",
    "href": "projects/final-project.html",
    "title": "Final Project",
    "section": "",
    "text": "This is coming down the pipeline. Check again later."
  },
  {
    "objectID": "projects/data-acquisition.html",
    "href": "projects/data-acquisition.html",
    "title": "Data Acquisition Project",
    "section": "",
    "text": "This is coming down the pipeline. Check again later."
  },
  {
    "objectID": "projects/eda.html",
    "href": "projects/eda.html",
    "title": "EDA Project",
    "section": "",
    "text": "This is coming down the pipeline. Check again later."
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects Overview",
    "section": "",
    "text": "Description: Pick a dataset and explore it to discover insights and answer questions.\n\n\n\nDescription: Find an interesting data source, collect the data, and prepare it for analysis.\n\n\n\nDescription: A comprehensive project that shows off my data science skills."
  },
  {
    "objectID": "projects/index.html#all-projects",
    "href": "projects/index.html#all-projects",
    "title": "Projects Overview",
    "section": "",
    "text": "Description: Pick a dataset and explore it to discover insights and answer questions.\n\n\n\nDescription: Find an interesting data source, collect the data, and prepare it for analysis.\n\n\n\nDescription: A comprehensive project that shows off my data science skills."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to My Data Science Portfolio",
    "section": "",
    "text": "Welcome to my data science portfolio! This site shows my journey learning data science and analytics. Here you’ll find projects that demonstrate what I’ve learned and discovered.\nYou can learn more about me on the About Me page.\n\n\nThis portfolio shows my work learning data science. Each project includes:\n\nMy code with documentation\nVisualizations I created\nWhat I learned and discovered\n\n\n\n\n\nProgramming: Python, Pandas for data analysis\nVisualization: Creating charts with Matplotlib and Seaborn\nData Collection: Getting data from files, websites, and APIs\nAnalysis: Finding patterns and answering questions with data\n\n\nThanks for visiting! Feel free to explore my projects and see what I’m learning.\nI built this site using Quarto and host it on GitHub Pages."
  },
  {
    "objectID": "index.html#about-this-portfolio",
    "href": "index.html#about-this-portfolio",
    "title": "Welcome to My Data Science Portfolio",
    "section": "",
    "text": "This portfolio shows my work learning data science. Each project includes:\n\nMy code with documentation\nVisualizations I created\nWhat I learned and discovered"
  },
  {
    "objectID": "index.html#skills-im-learning",
    "href": "index.html#skills-im-learning",
    "title": "Welcome to My Data Science Portfolio",
    "section": "",
    "text": "Programming: Python, Pandas for data analysis\nVisualization: Creating charts with Matplotlib and Seaborn\nData Collection: Getting data from files, websites, and APIs\nAnalysis: Finding patterns and answering questions with data\n\n\nThanks for visiting! Feel free to explore my projects and see what I’m learning.\nI built this site using Quarto and host it on GitHub Pages."
  }
]